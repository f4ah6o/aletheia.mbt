# Property-Based Tests for Aletheia

> Auto-generated by Aletheia - MoonBit PBT Tool

## Overview
- **Source**: `src/dogfooding`
- **Generated**: 2026-01-14
- **Patterns Detected**: 4

## Idempotent Properties

### `sort` Idempotence
Idempotent property: applying function twice should be same as applying once.

```mbt check
///|
test "prop_sort_idempotent" {
  let input = [3, 1, 2, 4, 5]
  input.sort()
  let sorted1 = input.copy()
  let sorted2 = sorted1.copy()
  sorted2.sort()
  inspect(sorted1 == sorted2, content="true")
}
```

### `normalize` Idempotence
Idempotent property: applying function twice should be same as applying once.

```mbt check
///|
test "prop_normalize_idempotent" {
  let input = "  hello  "
  let normalized1 = input.trim()
  let normalized2 = normalized1.trim()
  inspect(normalized1 == normalized2, content="true")
}
```

## Round-Trip Properties

### `parse_markdown` <-> `generate_markdown`
Round-trip property: parsing and generating should preserve structure.

```mbt check
///|
test "prop_parser_roundtrip_preserves_code_blocks" {
  let markdown = "# Title\nSome text\n```mbt check\nfn test() -> Int { 42 }\n```"
  let ast = @parser.parse_markdown(markdown)
  let regenerated = @parser.generate_markdown(ast)

  // 再生成された文字列をパースして、コードブロック数が一致することを確認
  let ast2 = @parser.parse_markdown(regenerated)
  inspect(ast.code_blocks.length() == ast2.code_blocks.length(), content="true")
}
```

### `parse_args` <-> `command_to_args`
Round-trip property: parsing and serializing commands should be reversible.

```mbt check
///|
test "prop_cli_roundtrip_analyze" {
  let original_args = ["moon-pbt-gen", "analyze", "./src"]
  let cmd = @cli.parse_args(original_args)
  let regenerated_args = @cli.command_to_args(cmd)
  let cmd2 = @cli.parse_args(regenerated_args)
  let result1 = match cmd {
    @cli.Command::Analyze(p) => p
    _ => "fail"
  }
  let result2 = match cmd2 {
    @cli.Command::Analyze(p) => p
    _ => "fail"
  }
  inspect(result1 == result2, content="true")
}
```

## Pattern Detection Properties

### Monotonicity
Pattern detection should be monotonic: more functions should not reduce detections.

```mbt check
///|
test "prop_pattern_detection_monotonic" {
  let a = ["encode_data", "decode_data"]
  let b = ["to_json", "from_json"]
  let results_a = @patterns.find_round_trips(a)
  let results_b = @patterns.find_round_trips(b)

  // a と b を結合
  let combined : Array[String] = []
  let mut i = 0
  while i < a.length() {
    combined.push(a[i])
    i = i + 1
  }
  let mut j = 0
  while j < b.length() {
    combined.push(b[j])
    j = j + 1
  }
  let results_combined = @patterns.find_round_trips(combined)

  // 結合結果は個別結果以上のパターンを含む
  inspect(results_combined.length() >= results_a.length(), content="true")
  inspect(results_combined.length() >= results_b.length(), content="true")
}
```

### Empty Input
Pattern detection with empty input should return empty results.

```mbt check
///|
test "prop_pattern_detection_empty_input" {
  let empty : Array[String] = []
  let rt = @patterns.find_round_trips(empty)
  let id = @patterns.find_idempotent_functions(empty)
  let pc = @patterns.find_producer_consumer(empty)
  inspect(rt.length(), content="0")
  inspect(id.length(), content="0")
  inspect(pc.length(), content="0")
}
```

## Generator Properties

### Determinism
Generator should produce same output for same input.

```mbt check
///|
test "prop_generator_deterministic" {
  let test1 = @generator.generate_round_trip_test("encode", "decode", "Data")
  let test2 = @generator.generate_round_trip_test("encode", "decode", "Data")
  inspect(test1.name == test2.name, content="true")
  inspect(test1.code == test2.code, content="true")
}
```
