# MoonBitにおけるMarkdown駆動型プロパティベーステスト：ドキュメントをOracleとする包括的検証アーキテクチャ

## 1. エグゼクティブサマリー

現代のソフトウェア開発において、ドキュメントとコードの乖離は永続的な課題である。MoonBit言語は、Markdownファイル（`*.mbt.md`）を実行可能なコンパイル単位として扱うことで、この課題に対する言語レベルの解決策を提示している。

本レポートは、MoonBitの標準ドキュメント形式であるmbt.mdファイルを、単なる説明文ではなく、Property-Based Testing (PBT) における「Oracle（神託：正解を決定する源）」として再定義し、自動化された検証プロセスに統合するためのアーキテクチャを提案・分析するものである。

具体的には、moonbitlang/quickcheckライブラリを基盤とし、MoonBitのコンパイラフロントエンド技術（Parser/AST解析）を用いて、ドキュメントから「テスト可能な関数」および「関数の有効な組み合わせ」を自動抽出する手法を詳述する。さらに、ユーザーまたはCoding Agentが定義したプロパティ定義と、抽出された実装の詳細を結合させ、ドキュメントに記述された仕様が実装と数学的に整合しているかを検証する「Markdown駆動型検証ループ」を構築する。

このアプローチは、MoonBitが目指すクラウドネイティブかつ高信頼な開発エコシステムにおいて、テストの自動化とドキュメントの信頼性を飛躍的に向上させるものである。

## 2. MoonBitにおけるテストエコシステムの基盤と進化

MoonBitのテスト環境は、従来の言語に見られる「後付けのツールチェーン」ではなく、言語設計の初期段階からコンパイラとビルドシステムに統合された中核機能として存在する。本章では、PBTの実装基盤となるmoonbitlang/quickcheckと、検証対象となるmbt.mdの特異な性質について分析する。

### 2.1 moonbitlang/quickcheck: 現代的PBTの実装

MoonBitにおけるプロパティベーステストの中核を担うのがmoonbitlang/quickcheckである。HaskellのQuickCheckに端を発するこのパラダイムは、個別の入力値に対する期待値を記述する従来のユニットテストとは異なり、関数が満たすべき普遍的な性質（プロパティ）を定義し、自動生成された膨大なランダム入力によってその性質が保持されるかを検証する。

MoonBit版QuickCheckの特徴は、MoonBitの型システム、特にインターフェース（trait）機構に深く統合されている点にある。Haskellのような一般化代数データ型（GADTs）を持たない代わりに、MoonBitのジェネリクスとトレイトを活用して柔軟なデータ生成を実現している。

#### QuickCheckのコンポーネント

| コンポーネント | 機能概要 | Oracle構築における役割 |
|---|---|---|
| Generators (Gen) | 指定された型のランダムな値を生成する関数 | テスト対象関数の引数空間を網羅的に探索するための入力源となる |
| Arbitrary Trait | 型Tに対してデフォルトのジェネレータを提供するインターフェース | Coding Agentが関数のシグネチャのみから適切なテストデータを自動生成する際の基盤となる |
| Shrinkers | テスト失敗時に反例を最小化するアルゴリズム | 自動生成された複雑な反例を人間が理解可能な形式（最小の再現手順）に縮小し、デバッグを支援する |
| quick_check! Macro | プロパティ検証の実行エントリポイント | ドキュメント内のtestブロックに埋め込まれ、定義されたプロパティを検証ランタイムに接続する |

このライブラリは現在も活発に開発が続けられており、コア機能の拡充やイテレータAPIの刷新などが行われている。これは、PBTがMoonBitのエコシステムにおいて実験的な位置付けから、標準的な検証手段へと移行しつつあることを示唆している。

### 2.2 *.mbt.md: 実行可能なドキュメントとしてのOracle

MoonBitの最も革新的な機能の一つが、Markdownファイル（`*.mbt.md`）の扱いである。これらは単なる静的なテキストファイルではなく、コンパイラによって解析され、型チェックおよびテスト実行の対象となる。

ビルドシステムmoonは、`moon test`コマンド実行時にパッケージ内の`*.mbt.md`ファイルをスキャンし、その中に含まれるコードブロックを抽出して実行する。この特性により、mbt.mdはPBTにおける理想的なOracleとなり得る。

通常、Oracle問題（テスト結果の正誤を判定する基準の欠如）はPBT導入の障壁となるが、mbt.mdには「関数の仕様（自然言語）」と「使用例（コード）」が共存している。例えば、ある関数が可換であることや、特定の条件下で例外を投げることなどが記述されていれば、それをプロパティとして形式化するだけで、ドキュメントそのものが検証ロジックへと昇華される。

Markdown内のコードブロックは、そのメタデータによって扱いが異なる。最新のアップデートでは、`mbt check`（型チェックのみ）や`mbt test`（テスト実行）といった明示的なタグ付けが可能になり、ドキュメントとしての可読性を損なうことなく、厳密な検証コードを埋め込むことが可能になった。

## 3. ドキュメントをOracleとする検証アーキテクチャ

本レポートが提案するアーキテクチャは、mbt.mdファイルを入力とし、そこから検証に必要な情報を抽出・構成し、quickcheckを用いたテストを実行する一連のパイプラインである。このプロセスは大きく分けて「静的解析による抽出フェーズ」と「動的検証フェーズ」に分類される。

### 3.1 全体アーキテクチャ図解

プロセスフローは以下の通りである：

1. **Parsing & Analysis**: moonbitlang/parserを用いてmbt.mdおよび関連する.mbtソースコードを解析し、AST（抽象構文木）を構築する。

2. **Extraction (A) - Testable Functions**: ASTから公開関数のシグネチャを抽出し、PBT適用可能性（引数がArbitraryを実装しているか等）を判定する。

3. **Extraction (B) - Usage Combinations**: ドキュメント内のコードブロックや実装コードの呼び出しグラフ（Call Graph）を解析し、関数間の依存関係や有効な呼び出しシーケンスを特定する。

4. **Property Synthesis**: Coding Agentまたはユーザー定義に基づき、抽出された情報を用いてquickcheckのプロパティコードを生成する。

5. **Execution & Feedback**: 生成されたテストを実行し、その結果（成功または反例）をフィードバックする。

このアーキテクチャの核心は、ドキュメントに書かれた「静的な知識」を、PBTを通じて「動的な保証」に変換する点にある。

## 4. コンポーネントA：テスト可能な関数の抽出と解析

自動化されたPBTを実現するためには、まず「何をテストできるか」をシステムが理解する必要がある。これにはMoonBitのソースコード解析技術が不可欠である。

### 4.1 ParserによるAST構築とシグネチャ抽出

MoonBitは自己ホスティングされたパーサライブラリmoonbitlang/parserを提供しており、これを利用することでソースコードの構造化された解析が可能である。

抽出プロセスは、mbt.mdファイル内のコードブロックおよびパッケージ内の.mbtファイルをパースすることから始まる。抽出対象となる主要なASTノードは、関数定義を表すStmt::Decl配下のFn構造体である。

抽出される主要情報：

- **関数名**: プロパティ定義の対象識別子。
- **引数リスト (args)**: 各引数の名前と型。ここで型情報（Type）が重要となる。
- **戻り値の型 (return_type)**: テスト結果の判定（等価性チェックなど）が可能かを判断するために使用。

具体的な抽出ロジックは以下の通りである：

1. `Parser::parse_string`を用いてコードをトークン列に変換し、構文解析を行う。
2. トップレベルの宣言（Declarations）を走査し、pub修飾子を持つ関数（外部からテスト可能なAPI）をフィルタリングする。
3. 関数のシグネチャを分析し、メタデータ（関数名、引数の型リスト、戻り値の型）を構造化データとして保存する。

### 4.2 Arbitraryトレイトによるテスト可能性の判定

関数が抽出されたとしても、その引数に対してランダムな値を生成できなければPBTは適用できない。ここで、moonbitlang/quickcheckのArbitraryトレイトが決定的な役割を果たす。

システムは、抽出された関数の引数の型TがArbitraryを実装しているかを検査する：

- **プリミティブ型** (`Int`, `String`, `Bool`): quickcheckが標準でジェネレータを提供しているため、即座にテスト可能である。
- **コンテナ型** (`List`, `Array`, `Map[K,V]`): 内部の型パラメータがArbitraryであれば、再帰的に生成可能である。
- **ユーザー定義型**: 明示的に`impl Arbitrary for MyType`が実装されている必要がある。

もしArbitraryの実装が見つからない場合、システムはこれを「PBT適用の阻害要因（Blocker）」として識別し、Coding Agentに対して「この型のArbitrary実装を生成せよ」というタスクを委譲することが可能になる。これにより、テストカバレッジの向上とテストインフラの拡充が相互に促進される。

### 4.3 副作用と純粋性の推定

PBTは参照透過な（純粋な）関数に対して最も効果を発揮する。抽出フェーズでは、関数本体（Body）のASTを走査し、副作用の有無を推定するヒューリスティックを適用する。

- **副作用の兆候**: Unit型の戻り値、IO操作（printlnなど）、可変参照（Ref）の操作が含まれる場合、単純なプロパティテストではなく、状態マシンテスト（後述）の候補として分類する。

- **純粋関数の候補**: 算術演算、データ構造の変換など、入力に対して決定論的な出力を返す構造を持つ場合、f(x)の形式で直接テスト可能とする。

## 5. コンポーネントB：使用している関数の組み合わせの抽出

単体の関数テストだけでは、システム全体の整合性は保証できない。特にオブジェクト指向的な振る舞いや、特定の順序で呼び出す必要があるAPIにおいては、「関数の組み合わせ（Combinations）」の抽出が重要となる。

### 5.1 Call Graph（呼び出しグラフ）の構築と連鎖解析

関数の組み合わせを特定するために、システムはAST内のExpr::Callノード（関数呼び出し式）やExpr::Methodノードを解析し、呼び出しグラフを構築する。このグラフから、以下のようなパターンを抽出する：

- **Producer-Consumerパターン**: 関数Aの戻り値の型がTであり、関数Bの入力引数の型がTである場合、B(A(x))という合成が可能である。これは「生成された値が正しく消費されるか」を検証するパイプラインテストの候補となる。

- **Round-Trip（可逆）パターン**: 関数AがT -> U、関数BがU -> Tというシグネチャを持つ場合（例：encodeとdecode、serializeとdeserialize）、B(A(x)) == xという強力な不変条件（Invariant）が自動的に示唆される。

- **Idempotence（べき等性）パターン**: 関数Aを二度適用しても結果が変わらない場合（A(A(x)) == A(x)）、これはsortやfilterなどの操作において一般的なプロパティである。

### 5.2 ドキュメントからのシーケンス抽出

mbt.mdファイル内のコードブロックは、APIの「正しい使い方」を示す貴重な情報源である。ユーザーが記述した例示コードは、暗黙のうちに「有効な関数呼び出しの順序」を規定している。システムはMarkdown内のnormalまたはcheckブロックを解析し、一連のステートメントを「トレース（Trace）」として抽出する。

例えば、以下のコードブロックがあったとする：

```moonbit
let q = Queue::new()
q.push(1)
let x = q.pop()
```

ここから、`new -> push -> pop` という有効な状態遷移シーケンス（Valid Sequence）が抽出される。このシーケンスは、後述する状態マシンテストにおける「コマンド列」の生成モデルとして利用される。ドキュメントに書かれた通りの順序でメソッドを呼び出した場合に、例外が発生せず、かつ期待される状態変化が起きるかを検証することは、ドキュメントの正確性を保証する上で極めて重要である。

## 6. プロパティ定義とCoding Agentの役割

抽出された情報（関数、型、組み合わせ）をもとに、実際に実行可能なPBTコードを生成するフェーズである。ここでは、ユーザーと協調するAI（Coding Agent）が中心的な役割を果たす。

### 6.1 Coding Agentによるプロパティ合成

Coding Agent（例：moonbitlang/asyncを用いて実装されたエージェント）は、自然言語で記述されたドキュメントと、解析されたAST情報を入力として受け取る。

#### シナリオ例

ドキュメント（mbt.md）に「rev関数はリストの要素を逆順にする。二回適用すると元のリストに戻る」と記述されている場合。

**自然言語理解**: Agentは「二回適用すると元に戻る (applied twice returns original)」という記述から、数学的な恒等式 `rev(rev(xs)) == xs` を推論する。

**コード生成**: quickcheckのマクロを用いて、以下のテストコードを生成し、mbt.md内のtestブロックとして挿入する。

```moonbit
///|
test "prop_reverse_involutive" {
  // Agentが生成したPBTコード
  quick_check!(
    |xs : List[Int]| { // Arbitraryな型としてIntのリストを選択
      xs.rev().rev() == xs
    }
  )
}
```

このプロセスにおいて、Agentは抽出された関数シグネチャを参照し、xsの型としてArbitraryが実装されている具体的な型（例：List[Int]）を選択して具体化（Instantiation）を行う。

### 6.2 ユーザー定義プロパティの統合

自動生成だけでなく、ユーザーが明示的にプロパティを定義する場合も、このアーキテクチャは有効に機能する。ユーザーはmbt.md内に、以下のような「仕様」を記述できる：

**性質**: 任意のリスト xs, ys について、`len(xs + ys) == len(xs) + len(ys)` が成り立つ。

システムはこの記述をパースし、対応する関数lenと演算子+をASTから検索し、その整合性を検証するテストコードの雛形を提示する。これにより、ユーザーは形式手法の専門知識がなくとも、堅牢な検証ロジックを実装に組み込むことができる。

## 7. 高度な検証：状態マシンテスト（State Machine Testing）

MoonBitのquickcheckエコシステムにおいて、最も強力かつ複雑な検証手法が「状態マシンテスト」である。これは、単純な関数入出力の検証を超えて、状態を持つシステム（キュー、データベース、UIコンポーネントなど）の振る舞いを検証するために用いられる。

### 7.1 モデルと実装の対比

ドキュメント（Oracle）としてmbt.mdを使用する場合、ドキュメント内で記述された「理想的な振る舞い（モデル）」と、実際のコードの「実装（SUT: System Under Test）」を比較するアプローチを採る。

- **モデル定義**: ドキュメント内で、簡易的なデータ構造（例えばMoonBitの不変Map）を用いて、APIの期待される動作を定義する。

- **コマンド定義**: APIに対する操作（Create, Read, Update, Deleteなど）を列挙型（enum）として定義する。

- **状態遷移検証**: quickcheckはランダムなコマンド列を生成し、それを「モデル」と「実装」の両方に適用する。

- **事後条件チェック**: 各ステップ実行後に、モデルの状態と実装の状態が整合しているか（等価であるか）を確認する。

### 7.2 競合状態と並列性の検証

quickcheck-state-machineの高度な機能として、並列実行時の競合状態（Race Conditions）の検出がある。MoonBitがサポートするスレッドや非同期処理（moonbitlang/async）と組み合わせることで、ドキュメントに「スレッドセーフである」と記載されたクラスに対して、実際に並列アクセスを行い、データの整合性が破壊されないかを検証することが可能になる。これは、単なるユニットテストでは発見が極めて困難なバグを炙り出す強力な手段となる。

## 8. 実装ロードマップと技術的詳細

本アーキテクチャを実現するための具体的な実装ステップと、使用されるMoonBitの技術スタックを以下に示す。

### 8.1 ステップ1: メタデータ抽出ツールの実装

まず、moonbitlang/parserを活用したCLIツール（moon-pbt-gen）を開発する。このツールは以下の機能を持つ：

- **Input**: moon.pkg.jsonを含むプロジェクトディレクトリ。
- **Process**: 全ての.mbtおよび.mbt.mdをパースし、関数シグネチャ、型定義、Arbitrary実装の有無をデータベース化する。
- **Output**: JSON形式のメタデータ（関数のリスト、依存関係、テスト可能な組み合わせの候補）。

### 8.2 ステップ2: PBTコードジェネレータの構築

抽出されたメタデータに基づき、quickcheckを利用したテストコードを自動生成する。

- **テンプレートエンジン**: mbt.mdの構文に準拠したコードブロックを生成する。
- **型解決**: ジェネリクス関数に対して、IntやStringなどの具体的な型を割り当てるロジック（ヒューリスティックまたは網羅的生成）を実装する。

### 8.3 ステップ3: テスト実行とレポート統合

`moon test`コマンドの出力を解析し、失敗したプロパティ（反例）をmbt.mdの該当箇所にアノテーションとして表示するIDE統合（VS Code拡張など）を行う。これにより、開発者はドキュメントを読みながら、その裏で実行された検証結果をリアルタイムに確認できる。

## 9. 結論

本レポートで提示した「MarkdownをOracleとするPBTアーキテクチャ」は、MoonBitの言語機能（ファーストクラスのMarkdownサポート、強力な型システム、高速なコンパイル）を最大限に活用した検証戦略である。

ドキュメントから自動的にテスト可能な関数を抽出し（Component A）、それらの有効な組み合わせを解析し（Component B）、AI支援によってプロパティ検証コードを生成・維持するこのループは、ドキュメントの陳腐化を防ぎ、ソフトウェアの堅牢性を継続的に保証する。

特に、moonbitlang/quickcheckの進化（Arbitraryトレイトや状態マシンテストのサポート）は、このアーキテクチャの実用性を裏付けている。

今後、MoonBitのエコシステムが成熟するにつれ、このような「ドキュメント駆動開発（Document-Driven Development）」と「プロパティベーステスト」の融合は、高品質なライブラリ開発の標準的な手法となっていくであろう。

ドキュメントはもはや静的な説明書ではなく、生きた仕様書であり、最強のテストスイートとなるのである。
